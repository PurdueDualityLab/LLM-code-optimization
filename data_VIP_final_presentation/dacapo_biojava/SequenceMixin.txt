{
    "0": [
        "\npackage org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\n\npublic class SequenceMixin {\n\n\t\n\tpublic static <C extends Compound> int countCompounds(\n\t\t\tSequence<C> sequence, C... compounds) {\n\t\tint count = 0;\n\t\tMap<C, Integer> compositon = getComposition(sequence);\n\t\tfor (C compound : compounds) {\n\t\t\tif(compositon.containsKey(compound)) {\n\t\t\t\tcount = compositon.get(compound) + count;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t\n\tpublic static int countGC(Sequence<NucleotideCompound> sequence) {\n\t\tCompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n\t\tNucleotideCompound G = cs.getCompoundForString(\"G\");\n\t\tNucleotideCompound C = cs.getCompoundForString(\"C\");\n\t\tNucleotideCompound g = cs.getCompoundForString(\"g\");\n\t\tNucleotideCompound c = cs.getCompoundForString(\"c\");\n\t\treturn countCompounds(sequence, G, C, g, c);\n\t}\n\n\t\n\tpublic static int countAT(Sequence<NucleotideCompound> sequence) {\n\t\tCompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n\t\tNucleotideCompound A = cs.getCompoundForString(\"A\");\n\t\tNucleotideCompound T = cs.getCompoundForString(\"T\");\n\t\tNucleotideCompound a = cs.getCompoundForString(\"a\");\n\t\tNucleotideCompound t = cs.getCompoundForString(\"t\");\n\t\treturn countCompounds(sequence, A, T, a, t);\n\t}\n\n\t\n\tpublic static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n\t\tMap<C, Double> results = new HashMap<C, Double>();\n\t\tMap<C, Integer> composition = getComposition(sequence);\n\t\tdouble length = sequence.getLength();\n\t\tfor (Map.Entry<C, Integer> entry : composition.entrySet()) {\n\t\t\tdouble dist = entry.getValue().doubleValue() / length;\n\t\t\tresults.put(entry.getKey(), dist);\n\t\t}\n\t\treturn results;\n\t}\n\n\t\n\tpublic static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n\t\tMap<C, Integer> results = new HashMap<C, Integer>();\n\n\t\tfor (C currentCompound : sequence) {\n\t\t\tInteger currentInteger = results.get(currentCompound);\n\t\t\tif ( currentInteger == null)\n\t\t\t\tcurrentInteger = 0;\n\t\t\tcurrentInteger++;\n\t\t\tresults.put(currentCompound, currentInteger);\n\t\t}\n\t\treturn results;\n\t}\n\n\t\n\tpublic static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n\t\tfor(C compound: sequence) {\n\t\t\tappendable.append(compound.toString());\n\t\t}\n\t}\n\n\t\n\tpublic static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n\t\tStringBuilder sb = new StringBuilder(sequence.getLength());\n\t\tfor (C compound : sequence) {\n\t\t\tsb.append(compound.toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\t\n\tpublic static <C extends Compound> String toString(Sequence<C> sequence) {\n\t\treturn toStringBuilder(sequence).toString();\n\t}\n\n\t\n\tpublic static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n\t\tList<C> list = new ArrayList<C>(sequence.getLength());\n\t\tfor (C compound : sequence) {\n\t\t\tlist.add(compound);\n\t\t}\n\t\treturn list;\n\t}\n\n\t\n\tpublic static <C extends Compound> int indexOf(Sequence<C> sequence,\n\t\t\tC compound) {\n\t\tint index = 1;\n\t\tfor (C currentCompound : sequence) {\n\t\t\tif (currentCompound.equals(compound)) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n\tpublic static <C extends Compound> int lastIndexOf(Sequence<C> sequence,\n\t\t\tC compound) {\n\t\tint index = indexOf(new ReversedSequenceView<C>(sequence), compound);\n\t\treturn (sequence.getLength() - index)+1;\n\t}\n\n\t\n\tpublic static <C extends Compound> Iterator<C> createIterator(\n\t\t\tSequence<C> sequence) {\n\t\treturn new SequenceIterator<C>(sequence);\n\t}\n\n\t\n\tpublic static <C extends Compound> SequenceView<C> createSubSequence(\n\t\t\tSequence<C> sequence, int start, int end) {\n\t\treturn new SequenceProxyView<C>(sequence, start, end);\n\t}\n\n\t\n\tpublic static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n\t\tList<C> compounds = sequence.getAsList();\n\t\tCollections.shuffle(compounds);\n\t\treturn new ArrayListSequenceReader<C>(compounds,\n\t\t\t\tsequence.getCompoundSet());\n\t}\n\n\t\n\tpublic static <C extends Compound> String checksum(Sequence<C> sequence) {\n\t\tCRC64Checksum checksum = new CRC64Checksum();\n\t\tfor (C compound : sequence) {\n\t\t\tchecksum.update(compound.getShortName());\n\t\t}\n\t\treturn checksum.toString();\n\t}\n\n\t\n\tpublic static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n\t\tList<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n\t\tWindowedSequence<C> w = new WindowedSequence<C>(sequence, kmer);\n\t\tfor(SequenceView<C> view: w) {\n\t\t\tl.add(view);\n\t\t}\n\t\treturn l;\n\t}\n\n\t\n\tpublic static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n\t\tList<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n\t\tList<Iterator<SequenceView<C>>> windows\n\t\t\t\t= new ArrayList<Iterator<SequenceView<C>>>();\n\n\t\tfor(int i=1; i<=kmer; i++) {\n\t\t\tif(i == 1) {\n\t\t\t\twindows.add(new WindowedSequence<C>(sequence, kmer).iterator());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n\t\t\t\twindows.add(new WindowedSequence<C>(sv, kmer).iterator());\n\t\t\t}\n\t\t}\n\n\t\tOUTER: while(true) {\n\t\t\tfor(int i=0; i<kmer; i++) {\n\t\t\t\tIterator<SequenceView<C>> iterator = windows.get(i);\n\t\t\t\tboolean breakLoop=true;\n\t\t\t\tif(iterator.hasNext()) {\n\t\t\t\t\tl.add(iterator.next());\n\t\t\t\t\tbreakLoop = false;\n\t\t\t\t}\n\t\t\t\tif(breakLoop) {\n\t\t\t\t\tbreak OUTER;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\n\t\n\t@SuppressWarnings({ \"unchecked\" })\n\tpublic static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n\t\tSequenceView<C> reverse = new ReversedSequenceView<C>(sequence);\n\t\tif(sequence.getCompoundSet().isComplementable()) {\n\t\t\treturn new ComplementSequenceView(reverse);\n\t\t}\n\t\treturn reverse;\n\t}\n\n\t\n\tpublic static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n\t\treturn baseSequenceEquality(source, target, true);\n\t}\n\n\t\n\tpublic static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n\t\treturn baseSequenceEquality(source, target, false);\n\t}\n\n\tprivate static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n\t\tboolean equal = true;\n\t\tif(\n\t\t\t\tsource.getLength() == target.getLength() &&\n\t\t\t\tsource.getCompoundSet().equals(target.getCompoundSet())) {\n\t\t\tIterator<C> sIter = source.iterator();\n\t\t\tIterator<C> tIter = target.iterator();\n\t\t\twhile(sIter.hasNext()) {\n\t\t\t\tC s = sIter.next();\n\t\t\t\tC t = tIter.next();\n\t\t\t\tboolean cEqual = (ignoreCase) ? s.equalsIgnoreCase(t) : s.equals(t);\n\t\t\t\tif(!cEqual) {\n\t\t\t\t\tequal = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tequal = false;\n\t\t}\n\t\treturn equal;\n\t}\n\n\t\n\tpublic static class SequenceIterator<C extends Compound>\n\t\t\timplements Iterator<C> {\n\n\t\tprivate final Sequence<C> sequence;\n\t\tprivate final int length;\n\t\tprivate int currentPosition = 0;\n\n\t\tpublic SequenceIterator(Sequence<C> sequence) {\n\t\t\tthis.sequence = sequence;\n\t\t\tthis.length = sequence.getLength();\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn (currentPosition < length);\n\t\t}\n\n\n\t\t@Override\n\t\tpublic C next() {\n\t\t\tif(!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException(\"Exhausted sequence of elements\");\n\t\t\t}\n\t\t\treturn sequence.getCompoundAt(++currentPosition);\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n\t\t}\n\t}\n}\n",
        134.635,
        2.163,
        6490073337.8,
        5841.6,
        0.462,
        273
    ],
    "1": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\nimport java.io.IOException;\nimport java.util.*;\n\npublic class SequenceMixin {\n\n    \n    private static Map<String, NucleotideCompound> nucleotideCache = new HashMap<>();\n\n    private static NucleotideCompound getCachedCompound(CompoundSet<NucleotideCompound> cs, String name) {\n        return nucleotideCache.computeIfAbsent(name, cs::getCompoundForString);\n    }\n\n    public static <C extends Compound> int countCompounds(\n            Sequence<C> sequence, C... compounds) {\n        int count = 0;\n        Map<C, Integer> composition = getComposition(sequence);\n        for (C compound : compounds) {\n            count += composition.getOrDefault(compound, 0);\n        }\n        return count;\n    }\n\n    public static int countGC(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        NucleotideCompound G = getCachedCompound(cs, \"G\");\n        NucleotideCompound C = getCachedCompound(cs, \"C\");\n        NucleotideCompound g = getCachedCompound(cs, \"g\");\n        NucleotideCompound c = getCachedCompound(cs, \"c\");\n        return countCompounds(sequence, G, C, g, c);\n    }\n\n    public static int countAT(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        NucleotideCompound A = getCachedCompound(cs, \"A\");\n        NucleotideCompound T = getCachedCompound(cs, \"T\");\n        NucleotideCompound a = getCachedCompound(cs, \"a\");\n        NucleotideCompound t = getCachedCompound(cs, \"t\");\n        return countCompounds(sequence, A, T, a, t);\n    }\n\n    public static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n        Map<C, Double> results = new HashMap<>();\n        Map<C, Integer> composition = getComposition(sequence);\n        double length = sequence.getLength();\n        composition.forEach((key, value) -> results.put(key, value / length));\n        return results;\n    }\n\n    public static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n        Map<C, Integer> results = new HashMap<>();\n        sequence.forEach(currentCompound ->\n                results.merge(currentCompound, 1, Integer::sum));\n        return results;\n    }\n\n    public static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n        \n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        sequence.forEach(compound -> sb.append(compound.toString()));\n        appendable.append(sb);\n    }\n    \n    public static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n        \n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        sequence.forEach(compound -> sb.append(compound.toString()));\n        return sb;\n    }\n\n    public static <C extends Compound> String toString(Sequence<C> sequence) {\n        return toStringBuilder(sequence).toString();\n    }\n\n    public static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n        return new ArrayList<>(sequence.getAsList());\n    }\n\n    \n    public static <C extends Compound> int indexOf(Sequence<C> sequence, C compound) {\n        int index = 1;\n        for (C currentCompound : sequence) {\n            if (currentCompound.equals(compound)) {\n                return index;\n            }\n            index++;\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> int lastIndexOf(Sequence<C> sequence, C compound) {\n        int index = indexOf(new ReversedSequenceView<>(sequence), compound);\n        return (sequence.getLength() - index) + 1;\n    }\n\n    public static <C extends Compound> Iterator<C> createIterator(Sequence<C> sequence) {\n        return new SequenceIterator<>(sequence);\n    }\n\n    public static <C extends Compound> SequenceView<C> createSubSequence(\n            Sequence<C> sequence, int start, int end) {\n        return new SequenceProxyView<>(sequence, start, end);\n    }\n\n    public static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n        List<C> compounds = new ArrayList<>(sequence.getAsList());\n        Collections.shuffle(compounds);\n        return new ArrayListSequenceReader<>(compounds, sequence.getCompoundSet());\n    }\n\n    public static <C extends Compound> String checksum(Sequence<C> sequence) {\n        CRC64Checksum checksum = new CRC64Checksum();\n        sequence.forEach(compound -> checksum.update(compound.getShortName()));\n        return checksum.toString();\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        Iterable<SequenceView<C>> w = new WindowedSequence<>(sequence, kmer);\n        w.forEach(l::add);\n        return l;\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        List<Iterator<SequenceView<C>>> windows = new ArrayList<>();\n\n        for (int i = 1; i <= kmer; i++) {\n            if (i == 1) {\n                windows.add(new WindowedSequence<>(sequence, kmer).iterator());\n            } else {\n                SequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n                windows.add(new WindowedSequence<>(sv, kmer).iterator());\n            }\n        }\n\n        OUTER:\n        while (true) {\n            for (Iterator<SequenceView<C>> iterator : windows) {\n                if (iterator.hasNext()) {\n                    l.add(iterator.next());\n                } else {\n                    break OUTER;\n                }\n            }\n        }\n        return l;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n        SequenceView<C> reverse = new ReversedSequenceView<>(sequence);\n        if (sequence.getCompoundSet().isComplementable()) {\n            return new ComplementSequenceView(reverse);\n        }\n        return reverse;\n    }\n\n    public static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, true);\n    }\n\n    public static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, false);\n    }\n\n    private static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n        if (source.getLength() != target.getLength() ||\n                !source.getCompoundSet().equals(target.getCompoundSet())) {\n            return false;\n        }\n\n        Iterator<C> sIter = source.iterator();\n        Iterator<C> tIter = target.iterator();\n        while (sIter.hasNext()) {\n            C s = sIter.next();\n            C t = tIter.next();\n            boolean cEqual = ignoreCase ? s.equalsIgnoreCase(t) : s.equals(t);\n            if (!cEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class SequenceIterator<C extends Compound>\n            implements Iterator<C> {\n\n        private final Sequence<C> sequence;\n        private final int length;\n        private int currentPosition = 0;\n\n        public SequenceIterator(Sequence<C> sequence) {\n            this.sequence = sequence;\n            this.length = sequence.getLength();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return (currentPosition < length);\n        }\n\n        @Override\n        public C next() {\n            if(!hasNext()) {\n                throw new NoSuchElementException(\"Exhausted sequence of elements\");\n            }\n            return sequence.getCompoundAt(++currentPosition);\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n",
        1.012,
        1.013,
        1.0133190078707892,
        0.9815835461755613,
        1.0138095238095237,
        232
    ],
    "2": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class SequenceMixin {\n\n    \n    private static final Map<String, NucleotideCompound> nucleotideCache = new ConcurrentHashMap<>();\n\n    private static NucleotideCompound getCachedCompound(CompoundSet<NucleotideCompound> cs, String name) {\n        return nucleotideCache.computeIfAbsent(name, cs::getCompoundForString);\n    }\n\n    public static <C extends Compound> int countCompounds(\n            Sequence<C> sequence, C... compounds) {\n        Map<C, Integer> composition = getComposition(sequence);\n        int count = 0;\n        for (C compound : compounds) {\n            count += composition.getOrDefault(compound, 0);\n        }\n        return count;\n    }\n\n    public static int countGC(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        return countCompounds(sequence, getCachedCompound(cs, \"G\"), getCachedCompound(cs, \"C\"),\n                getCachedCompound(cs, \"g\"), getCachedCompound(cs, \"c\"));\n    }\n\n    public static int countAT(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        return countCompounds(sequence, getCachedCompound(cs, \"A\"), getCachedCompound(cs, \"T\"),\n                getCachedCompound(cs, \"a\"), getCachedCompound(cs, \"t\"));\n    }\n\n    public static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n        Map<C, Integer> composition = getComposition(sequence);\n        double length = sequence.getLength();\n        Map<C, Double> results = new HashMap<>();\n        for (Map.Entry<C, Integer> entry : composition.entrySet()) {\n            results.put(entry.getKey(), entry.getValue() / length);\n        }\n        return results;\n    }\n\n    public static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n        Map<C, Integer> results = new HashMap<>();\n        for (C currentCompound : sequence) {\n            results.merge(currentCompound, 1, Integer::sum);\n        }\n        return results;\n    }\n\n    public static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        for (C compound : sequence) {\n            sb.append(compound.toString());\n        }\n        appendable.append(sb);\n    }\n\n    public static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        for (C compound : sequence) {\n            sb.append(compound.toString());\n        }\n        return sb;\n    }\n\n    public static <C extends Compound> String toString(Sequence<C> sequence) {\n        return toStringBuilder(sequence).toString();\n    }\n\n    public static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n        List<C> list = new ArrayList<>(sequence.getLength());\n        for (C compound : sequence) {\n            list.add(compound);\n        }\n        return list;\n    }\n\n    public static <C extends Compound> int indexOf(Sequence<C> sequence, C compound) {\n        int index = 1;\n        for (C currentCompound : sequence) {\n            if (currentCompound.equals(compound)) {\n                return index;\n            }\n            index++;\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> int lastIndexOf(Sequence<C> sequence, C compound) {\n        int index = indexOf(new ReversedSequenceView<>(sequence), compound);\n        return (sequence.getLength() - index) + 1;\n    }\n\n    public static <C extends Compound> Iterator<C> createIterator(Sequence<C> sequence) {\n        return new SequenceIterator<>(sequence);\n    }\n\n    public static <C extends Compound> SequenceView<C> createSubSequence(\n            Sequence<C> sequence, int start, int end) {\n        return new SequenceProxyView<>(sequence, start, end);\n    }\n\n    public static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n        List<C> compounds = new ArrayList<>(sequence.getAsList());\n        Collections.shuffle(compounds);\n        return new ArrayListSequenceReader<>(compounds, sequence.getCompoundSet());\n    }\n\n    public static <C extends Compound> String checksum(Sequence<C> sequence) {\n        CRC64Checksum checksum = new CRC64Checksum();\n        for (C compound : sequence) {\n            checksum.update(compound.getShortName());\n        }\n        return checksum.toString();\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        Iterable<SequenceView<C>> w = new WindowedSequence<>(sequence, kmer);\n        for (SequenceView<C> view : w) {\n            l.add(view);\n        }\n        return l;\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        List<Iterator<SequenceView<C>>> windows = new ArrayList<>();\n\n        for (int i = 1; i <= kmer; i++) {\n            if (i == 1) {\n                windows.add(new WindowedSequence<>(sequence, kmer).iterator());\n            } else {\n                SequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n                windows.add(new WindowedSequence<>(sv, kmer).iterator());\n            }\n        }\n\n        OUTER:\n        while (true) {\n            for (Iterator<SequenceView<C>> iterator : windows) {\n                if (iterator.hasNext()) {\n                    l.add(iterator.next());\n                } else {\n                    break OUTER;\n                }\n            }\n        }\n        return l;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n        SequenceView<C> reverse = new ReversedSequenceView<>(sequence);\n        if (sequence.getCompoundSet().isComplementable()) {\n            return new ComplementSequenceView(reverse);\n        }\n        return reverse;\n    }\n\n    public static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, true);\n    }\n\n    public static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, false);\n    }\n\n    private static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n        if (source.getLength() != target.getLength() ||\n                !source.getCompoundSet().equals(target.getCompoundSet())) {\n            return false;\n        }\n\n        Iterator<C> sIter = source.iterator();\n        Iterator<C> tIter = target.iterator();\n        while (sIter.hasNext()) {\n            C s = sIter.next();\n            C t = tIter.next();\n            boolean cEqual = ignoreCase ? s.equalsIgnoreCase(t) : s.equals(t);\n            if (!cEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class SequenceIterator<C extends Compound>\n            implements Iterator<C> {\n\n        private final Sequence<C> sequence;\n        private final int length;\n        private int currentPosition = 0;\n\n        public SequenceIterator(Sequence<C> sequence) {\n            this.sequence = sequence;\n            this.length = sequence.getLength();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return (currentPosition < length);\n        }\n\n        @Override\n        public C next() {\n            if(!hasNext()) {\n                throw new NoSuchElementException(\"Exhausted sequence of elements\");\n            }\n            return sequence.getCompoundAt(++currentPosition);\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n        }\n    }\n}\n",
        1.009,
        1.001,
        1.001080679061195,
        0.970494417862839,
        1.001564935064935,
        231
    ]
}