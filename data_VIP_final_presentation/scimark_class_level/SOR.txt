{
    "0": [
        "package jnt.scimark2;\n\nimport java.util.Random;\n\npublic class SOROptimized {\n    // Executes the Successive Over-Relaxation (SOR) algorithm.\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        // Update interior points for each iteration.\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i++) {\n                double[] Gi = G[i];\n                double[] Gim1 = G[i - 1];\n                double[] Gip1 = G[i + 1];\n                for (int j = 1; j < Nm1; j++) {\n                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1])\n                            + one_minus_omega * Gi[j];\n                }\n            }\n        }\n    }\n\n    // Helper method to generate a random matrix with dimensions M x N.\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n\n        return sum;\n    }\n\n    /**\n    * Main method, do not change.\n    */\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;      \n        final long cycles = 65536;      // Fixed number of iterations.\n        double omega = 1.25;            // Relaxation factor\n\n        // Create a random matrix of dimensions SOR_SIZE x SOR_SIZE.\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n\n        // Execute the SOR algorithm.\n        execute(omega, G, cycles);\n\n        // Compute the error between the two matrices (should be 0.0 for a matrix of random values)\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n\n        // Print the error result\n        System.out.println(error * 1.0e-6);\n    }\n}\n\n\n",
        101.276,
        2.196,
        6587919710.6,
        45716.0,
        0.455,
        1861.79,
        79
    ],
    "1": [
        "package jnt.scimark2;\n\nimport java.util.Random;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class SOROptimized {\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        int Mm1 = M - 1;\n        int Nm1 = N - 1;\n        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());\n\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < Mm1; i += 2) { \n                final int fi = i;\n                executor.submit(() -> {\n                    double[] Gi = G[fi];\n                    double[] Gip1 = G[fi + 1];\n                    double[] Gim1 = G[fi - 1];\n                    double[] Gip2 = (fi + 2 < M) ? G[fi + 2] : new double[N];\n                    for (int j = 1; j < Nm1; j++) {\n                        Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1]) + one_minus_omega * Gi[j];\n                        if (fi + 1 < Mm1)\n                            Gip1[j] = omega_over_four * (Gi[j] + Gip2[j] + Gip1[j - 1] + Gip1[j + 1]) + one_minus_omega * Gip1[j];\n                    }\n                });\n            }\n        }\n\n        \n        executor.shutdown();\n        try {\n            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;\n        final long cycles = 65536;\n        double omega = 1.25;\n\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n        execute(omega, G, cycles);\n\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n        System.out.println(error * 1.0e-6);\n    }\n}",
        0.338,
        0.217,
        0.21733038419617842,
        0.07623704257107408,
        0.2175076923076923,
        0.2968165045466997,
        79
    ],
    "2": [
        "package jnt.scimark2;\n\nimport java.util.Random;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class SOROptimized {\n    public static void execute(double omega, double[][] G, long num_iterations) {\n        int M = G.length;\n        int N = G[0].length;\n        double omega_over_four = omega * 0.25;\n        double one_minus_omega = 1.0 - omega;\n\n        int numCores = Runtime.getRuntime().availableProcessors();\n        ExecutorService executor = Executors.newFixedThreadPool(numCores);\n\n        for (long p = 0; p < num_iterations; p++) {\n            for (int i = 1; i < M - 1; i += numCores) { \n                final int fi = i;\n                final int limit = Math.min(fi + numCores, M - 1);\n                executor.submit(() -> {\n                    for (int ii = fi; ii < limit; ii++) {\n                        double[] Gi = G[ii];\n                        double[] Gip1 = G[ii + 1];\n                        double[] Gim1 = G[ii - 1];\n                        for (int j = 1; j < N - 1; j++) {\n                            Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j - 1] + Gi[j + 1]) + one_minus_omega * Gi[j];\n                        }\n                    }\n                });\n            }\n        }\n\n        executor.shutdown();\n        try {\n            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static double[][] randomMatrix(int M, int N) {\n        double[][] A = new double[M][N];\n        Random R = new Random(101010);\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                A[i][j] = R.nextDouble();\n            }\n        }\n        return A;\n    }\n\n    private static double normabs(double[] x, double[] y) {\n        int N = x.length;\n        double sum = 0.0;\n        for (int i = 0; i < N; i++)\n            sum += Math.abs(x[i] - y[i]);\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int SOR_SIZE = 100;\n        final long cycles = 65536;\n        double omega = 1.25;\n\n        double[][] G = randomMatrix(SOR_SIZE, SOR_SIZE);\n        execute(omega, G, cycles);\n\n        double[][] G_baseline = randomMatrix(SOR_SIZE, SOR_SIZE);\n        double error = 0.0;\n        for (int i = 0; i < SOR_SIZE; i++) {\n            error += normabs(G[i], G_baseline[i]);\n        }\n        System.out.println(error * 1.0e-6);\n    }\n}\n\n",
        0.742,
        2.09,
        2.090281938711363,
        0.5672410712513152,
        2.0919142857142856,
        5.359229558650546,
        78
    ]
}