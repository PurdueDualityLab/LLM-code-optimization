{
    "0": [
        "\npackage org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\n\npublic class SequenceMixin {\n\n\t\n\tpublic static <C extends Compound> int countCompounds(\n\t\t\tSequence<C> sequence, C... compounds) {\n\t\tint count = 0;\n\t\tMap<C, Integer> compositon = getComposition(sequence);\n\t\tfor (C compound : compounds) {\n\t\t\tif(compositon.containsKey(compound)) {\n\t\t\t\tcount = compositon.get(compound) + count;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t\n\tpublic static int countGC(Sequence<NucleotideCompound> sequence) {\n\t\tCompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n\t\tNucleotideCompound G = cs.getCompoundForString(\"G\");\n\t\tNucleotideCompound C = cs.getCompoundForString(\"C\");\n\t\tNucleotideCompound g = cs.getCompoundForString(\"g\");\n\t\tNucleotideCompound c = cs.getCompoundForString(\"c\");\n\t\treturn countCompounds(sequence, G, C, g, c);\n\t}\n\n\t\n\tpublic static int countAT(Sequence<NucleotideCompound> sequence) {\n\t\tCompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n\t\tNucleotideCompound A = cs.getCompoundForString(\"A\");\n\t\tNucleotideCompound T = cs.getCompoundForString(\"T\");\n\t\tNucleotideCompound a = cs.getCompoundForString(\"a\");\n\t\tNucleotideCompound t = cs.getCompoundForString(\"t\");\n\t\treturn countCompounds(sequence, A, T, a, t);\n\t}\n\n\t\n\tpublic static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n\t\tMap<C, Double> results = new HashMap<C, Double>();\n\t\tMap<C, Integer> composition = getComposition(sequence);\n\t\tdouble length = sequence.getLength();\n\t\tfor (Map.Entry<C, Integer> entry : composition.entrySet()) {\n\t\t\tdouble dist = entry.getValue().doubleValue() / length;\n\t\t\tresults.put(entry.getKey(), dist);\n\t\t}\n\t\treturn results;\n\t}\n\n\t\n\tpublic static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n\t\tMap<C, Integer> results = new HashMap<C, Integer>();\n\n\t\tfor (C currentCompound : sequence) {\n\t\t\tInteger currentInteger = results.get(currentCompound);\n\t\t\tif ( currentInteger == null)\n\t\t\t\tcurrentInteger = 0;\n\t\t\tcurrentInteger++;\n\t\t\tresults.put(currentCompound, currentInteger);\n\t\t}\n\t\treturn results;\n\t}\n\n\t\n\tpublic static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n\t\tfor(C compound: sequence) {\n\t\t\tappendable.append(compound.toString());\n\t\t}\n\t}\n\n\t\n\tpublic static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n\t\tStringBuilder sb = new StringBuilder(sequence.getLength());\n\t\tfor (C compound : sequence) {\n\t\t\tsb.append(compound.toString());\n\t\t}\n\t\treturn sb;\n\t}\n\n\t\n\tpublic static <C extends Compound> String toString(Sequence<C> sequence) {\n\t\treturn toStringBuilder(sequence).toString();\n\t}\n\n\t\n\tpublic static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n\t\tList<C> list = new ArrayList<C>(sequence.getLength());\n\t\tfor (C compound : sequence) {\n\t\t\tlist.add(compound);\n\t\t}\n\t\treturn list;\n\t}\n\n\t\n\tpublic static <C extends Compound> int indexOf(Sequence<C> sequence,\n\t\t\tC compound) {\n\t\tint index = 1;\n\t\tfor (C currentCompound : sequence) {\n\t\t\tif (currentCompound.equals(compound)) {\n\t\t\t\treturn index;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n\tpublic static <C extends Compound> int lastIndexOf(Sequence<C> sequence,\n\t\t\tC compound) {\n\t\tint index = indexOf(new ReversedSequenceView<C>(sequence), compound);\n\t\treturn (sequence.getLength() - index)+1;\n\t}\n\n\t\n\tpublic static <C extends Compound> Iterator<C> createIterator(\n\t\t\tSequence<C> sequence) {\n\t\treturn new SequenceIterator<C>(sequence);\n\t}\n\n\t\n\tpublic static <C extends Compound> SequenceView<C> createSubSequence(\n\t\t\tSequence<C> sequence, int start, int end) {\n\t\treturn new SequenceProxyView<C>(sequence, start, end);\n\t}\n\n\t\n\tpublic static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n\t\tList<C> compounds = sequence.getAsList();\n\t\tCollections.shuffle(compounds);\n\t\treturn new ArrayListSequenceReader<C>(compounds,\n\t\t\t\tsequence.getCompoundSet());\n\t}\n\n\t\n\tpublic static <C extends Compound> String checksum(Sequence<C> sequence) {\n\t\tCRC64Checksum checksum = new CRC64Checksum();\n\t\tfor (C compound : sequence) {\n\t\t\tchecksum.update(compound.getShortName());\n\t\t}\n\t\treturn checksum.toString();\n\t}\n\n\t\n\tpublic static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n\t\tList<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n\t\tWindowedSequence<C> w = new WindowedSequence<C>(sequence, kmer);\n\t\tfor(SequenceView<C> view: w) {\n\t\t\tl.add(view);\n\t\t}\n\t\treturn l;\n\t}\n\n\t\n\tpublic static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n\t\tList<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n\t\tList<Iterator<SequenceView<C>>> windows\n\t\t\t\t= new ArrayList<Iterator<SequenceView<C>>>();\n\n\t\tfor(int i=1; i<=kmer; i++) {\n\t\t\tif(i == 1) {\n\t\t\t\twindows.add(new WindowedSequence<C>(sequence, kmer).iterator());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n\t\t\t\twindows.add(new WindowedSequence<C>(sv, kmer).iterator());\n\t\t\t}\n\t\t}\n\n\t\tOUTER: while(true) {\n\t\t\tfor(int i=0; i<kmer; i++) {\n\t\t\t\tIterator<SequenceView<C>> iterator = windows.get(i);\n\t\t\t\tboolean breakLoop=true;\n\t\t\t\tif(iterator.hasNext()) {\n\t\t\t\t\tl.add(iterator.next());\n\t\t\t\t\tbreakLoop = false;\n\t\t\t\t}\n\t\t\t\tif(breakLoop) {\n\t\t\t\t\tbreak OUTER;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\n\t\n\t@SuppressWarnings({ \"unchecked\" })\n\tpublic static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n\t\tSequenceView<C> reverse = new ReversedSequenceView<C>(sequence);\n\t\tif(sequence.getCompoundSet().isComplementable()) {\n\t\t\treturn new ComplementSequenceView(reverse);\n\t\t}\n\t\treturn reverse;\n\t}\n\n\t\n\tpublic static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n\t\treturn baseSequenceEquality(source, target, true);\n\t}\n\n\t\n\tpublic static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n\t\treturn baseSequenceEquality(source, target, false);\n\t}\n\n\tprivate static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n\t\tboolean equal = true;\n\t\tif(\n\t\t\t\tsource.getLength() == target.getLength() &&\n\t\t\t\tsource.getCompoundSet().equals(target.getCompoundSet())) {\n\t\t\tIterator<C> sIter = source.iterator();\n\t\t\tIterator<C> tIter = target.iterator();\n\t\t\twhile(sIter.hasNext()) {\n\t\t\t\tC s = sIter.next();\n\t\t\t\tC t = tIter.next();\n\t\t\t\tboolean cEqual = (ignoreCase) ? s.equalsIgnoreCase(t) : s.equals(t);\n\t\t\t\tif(!cEqual) {\n\t\t\t\t\tequal = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tequal = false;\n\t\t}\n\t\treturn equal;\n\t}\n\n\t\n\tpublic static class SequenceIterator<C extends Compound>\n\t\t\timplements Iterator<C> {\n\n\t\tprivate final Sequence<C> sequence;\n\t\tprivate final int length;\n\t\tprivate int currentPosition = 0;\n\n\t\tpublic SequenceIterator(Sequence<C> sequence) {\n\t\t\tthis.sequence = sequence;\n\t\t\tthis.length = sequence.getLength();\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn (currentPosition < length);\n\t\t}\n\n\n\t\t@Override\n\t\tpublic C next() {\n\t\t\tif(!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException(\"Exhausted sequence of elements\");\n\t\t\t}\n\t\t\treturn sequence.getCompoundAt(++currentPosition);\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n\t\t}\n\t}\n}\n",
        137.539,
        2.276,
        25258504546.6,
        21044.8,
        0.439,
        273
    ],
    "1": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\npublic class SequenceMixin {\n\n    public static <C extends Compound> int countCompounds(\n            Sequence<C> sequence, C... compounds) {\n        Map<C, Integer> composition = getComposition(sequence);\n        return Arrays.stream(compounds)\n                .mapToInt(compound -> composition.getOrDefault(compound, 0))\n                .sum();\n    }\n\n    public static int countGC(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        return countCompounds(sequence,\n                cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"C\"),\n                cs.getCompoundForString(\"g\"), cs.getCompoundForString(\"c\"));\n    }\n\n    public static int countAT(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        return countCompounds(sequence,\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"T\"),\n                cs.getCompoundForString(\"a\"), cs.getCompoundForString(\"t\"));\n    }\n\n    public static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n        Map<C, Integer> composition = getComposition(sequence);\n        double length = sequence.getLength();\n        Map<C, Double> results = new HashMap<>();\n\n        composition.forEach((key, value) -> results.put(key, value / length));\n\n        return results;\n    }\n\n    public static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n        Map<C, Integer> results = new HashMap<>();\n\n        sequence.forEach(compound ->\n                results.merge(compound, 1, Integer::sum)\n        );\n        return results;\n    }\n\n    public static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n        for (C compound : sequence) {\n            appendable.append(compound.toString());\n        }\n    }\n\n    public static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        sequence.forEach(compound -> sb.append(compound.toString()));\n        return sb;\n    }\n\n    public static <C extends Compound> String toString(Sequence<C> sequence) {\n        return toStringBuilder(sequence).toString();\n    }\n\n    public static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n        List<C> list = new ArrayList<>(sequence.getLength());\n        sequence.forEach(list::add);\n        return list;\n    }\n\n    public static <C extends Compound> int indexOf(Sequence<C> sequence, C compound) {\n        int index = 1;\n        for (C currentCompound : sequence) {\n            if (currentCompound.equals(compound)) {\n                return index;\n            }\n            index++;\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> int lastIndexOf(Sequence<C> sequence, C compound) {\n        int index = indexOf(new ReversedSequenceView<>(sequence), compound);\n        return (sequence.getLength() - index) + 1;\n    }\n\n    public static <C extends Compound> Iterator<C> createIterator(Sequence<C> sequence) {\n        return new SequenceIterator<>(sequence);\n    }\n\n    public static <C extends Compound> SequenceView<C> createSubSequence(Sequence<C> sequence, int start, int end) {\n        return new SequenceProxyView<>(sequence, start, end);\n    }\n\n    public static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n        List<C> compounds = sequence.getAsList();\n        Collections.shuffle(compounds);\n        return new ArrayListSequenceReader<>(compounds, sequence.getCompoundSet());\n    }\n\n    public static <C extends Compound> String checksum(Sequence<C> sequence) {\n        CRC64Checksum checksum = new CRC64Checksum();\n        sequence.forEach(compound -> checksum.update(compound.getShortName()));\n        return checksum.toString();\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        WindowedSequence<C> w = new WindowedSequence<>(sequence, kmer);\n        w.forEach(l::add);\n        return l;\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        List<Iterator<SequenceView<C>>> windows = new ArrayList<>();\n\n        for (int i = 1; i <= kmer; i++) {\n            if (i == 1) {\n                windows.add(new WindowedSequence<>(sequence, kmer).iterator());\n            } else {\n                SequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n                windows.add(new WindowedSequence<>(sv, kmer).iterator());\n            }\n        }\n\n        while (true) {\n            boolean shouldBreak = true;\n            for (int i = 0; i < kmer; i++) {\n                Iterator<SequenceView<C>> iterator = windows.get(i);\n                if (iterator.hasNext()) {\n                    l.add(iterator.next());\n                    shouldBreak = false;\n                }\n            }\n            if (shouldBreak) break;\n        }\n        return l;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n        SequenceView<C> reverse = new ReversedSequenceView<>(sequence);\n        if (sequence.getCompoundSet().isComplementable()) {\n            return new ComplementSequenceView(reverse);\n        }\n        return reverse;\n    }\n\n    public static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, true);\n    }\n\n    public static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, false);\n    }\n\n    private static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n        if (source.getLength() != target.getLength() || \n            !source.getCompoundSet().equals(target.getCompoundSet())) {\n            return false;\n        }\n\n        Iterator<C> sIter = source.iterator();\n        Iterator<C> tIter = target.iterator();\n        while (sIter.hasNext()) {\n            C s = sIter.next();\n            C t = tIter.next();\n            boolean cEqual = ignoreCase ? s.equalsIgnoreCase(t) : s.equals(t);\n            if (!cEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class SequenceIterator<C extends Compound> implements Iterator<C> {\n\n        private final Sequence<C> sequence;\n        private final int length;\n        private int currentPosition = 0;\n\n        public SequenceIterator(Sequence<C> sequence) {\n            this.sequence = sequence;\n            this.length = sequence.getLength();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return currentPosition < length;\n        }\n\n        @Override\n        public C next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"Exhausted sequence of elements\");\n            }\n            return sequence.getCompoundAt(++currentPosition);\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n        }\n    }\n}\n",
        0.995,
        0.993,
        0.9832140027393775,
        1.00083701110942,
        0.9940865603644647,
        213
    ],
    "2": [
        "package org.biojava.nbio.core.sequence.template;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.storage.ArrayListSequenceReader;\nimport org.biojava.nbio.core.sequence.views.ComplementSequenceView;\nimport org.biojava.nbio.core.sequence.views.ReversedSequenceView;\nimport org.biojava.nbio.core.sequence.views.WindowedSequence;\nimport org.biojava.nbio.core.util.CRC64Checksum;\n\nimport java.io.IOException;\nimport java.util.*;\n\npublic class SequenceMixin {\n\n    private static final Map<Sequence<?>, Map<?, Integer>> compositionCache = Collections.synchronizedMap(new WeakHashMap<>());\n\n    public static <C extends Compound> int countCompounds(Sequence<C> sequence, C... compounds) {\n        Map<C, Integer> composition = getCompositionWithCache(sequence);\n        return Arrays.stream(compounds)\n                .parallel()\n                .mapToInt(compound -> composition.getOrDefault(compound, 0))\n                .sum();\n    }\n\n    public static int countGC(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        return countCompounds(sequence,\n                cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"C\"),\n                cs.getCompoundForString(\"g\"), cs.getCompoundForString(\"c\"));\n    }\n\n    public static int countAT(Sequence<NucleotideCompound> sequence) {\n        CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n        return countCompounds(sequence,\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"T\"),\n                cs.getCompoundForString(\"a\"), cs.getCompoundForString(\"t\"));\n    }\n\n    public static <C extends Compound> Map<C, Double> getDistribution(Sequence<C> sequence) {\n        Map<C, Integer> composition = getCompositionWithCache(sequence);\n        double length = sequence.getLength();\n        Map<C, Double> results = new HashMap<>();\n\n        composition.forEach((key, value) -> results.put(key, value / length));\n\n        return results;\n    }\n\n    public static <C extends Compound> Map<C, Integer> getCompositionWithCache(Sequence<C> sequence) {\n        return (Map<C, Integer>) compositionCache.computeIfAbsent(sequence, seq -> getComposition(seq));\n    }\n\n    private static <C extends Compound> Map<C, Integer> getComposition(Sequence<C> sequence) {\n        Map<C, Integer> results = new HashMap<>();\n        sequence.forEach(compound ->\n                results.merge(compound, 1, Integer::sum)\n        );\n        return results;\n    }\n\n    public static <C extends Compound> void write(Appendable appendable, Sequence<C> sequence) throws IOException {\n        for (C compound : sequence) {\n            appendable.append(compound.toString());\n        }\n    }\n\n    public static <C extends Compound> StringBuilder toStringBuilder(Sequence<C> sequence) {\n        StringBuilder sb = new StringBuilder(sequence.getLength());\n        sequence.forEach(compound -> sb.append(compound.toString()));\n        return sb;\n    }\n\n    public static <C extends Compound> String toString(Sequence<C> sequence) {\n        return toStringBuilder(sequence).toString();\n    }\n\n    public static <C extends Compound> List<C> toList(Sequence<C> sequence) {\n        List<C> list = new ArrayList<>(sequence.getLength());\n        sequence.forEach(list::add);\n        return list;\n    }\n\n    public static <C extends Compound> int indexOf(Sequence<C> sequence, C compound) {\n        int index = 1;\n        for (C currentCompound : sequence) {\n            if (currentCompound.equals(compound)) {\n                return index;\n            }\n            index++;\n        }\n        return 0;\n    }\n\n    public static <C extends Compound> int lastIndexOf(Sequence<C> sequence, C compound) {\n        int index = indexOf(new ReversedSequenceView<>(sequence), compound);\n        return (sequence.getLength() - index) + 1;\n    }\n\n    public static <C extends Compound> Iterator<C> createIterator(Sequence<C> sequence) {\n        return new SequenceIterator<>(sequence);\n    }\n\n    public static <C extends Compound> SequenceView<C> createSubSequence(Sequence<C> sequence, int start, int end) {\n        return new SequenceProxyView<>(sequence, start, end);\n    }\n\n    public static <C extends Compound> Sequence<C> shuffle(Sequence<C> sequence) {\n        List<C> compounds = sequence.getAsList();\n        Collections.shuffle(compounds);\n        return new ArrayListSequenceReader<>(compounds, sequence.getCompoundSet());\n    }\n\n    public static <C extends Compound> String checksum(Sequence<C> sequence) {\n        CRC64Checksum checksum = new CRC64Checksum();\n        sequence.forEach(compound -> checksum.update(compound.getShortName()));\n        return checksum.toString();\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> nonOverlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        WindowedSequence<C> w = new WindowedSequence<>(sequence, kmer);\n        w.forEach(l::add);\n        return l;\n    }\n\n    public static <C extends Compound> List<SequenceView<C>> overlappingKmers(Sequence<C> sequence, int kmer) {\n        List<SequenceView<C>> l = new ArrayList<>();\n        List<Iterator<SequenceView<C>>> windows = new ArrayList<>();\n\n        for (int i = 1; i <= kmer; i++) {\n            SequenceView<C> sv = (i == 1) ? new SequenceProxyView<>(sequence, 1, sequence.getLength()) : sequence.getSubSequence(i, sequence.getLength());\n            windows.add(new WindowedSequence<>(sv, kmer).iterator());\n        }\n\n        boolean hasMore;\n        do {\n            hasMore = false;\n            for (Iterator<SequenceView<C>> iterator : windows) {\n                if (iterator.hasNext()) {\n                    l.add(iterator.next());\n                    hasMore = true;\n                }\n            }\n        } while (hasMore);\n\n        return l;\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    public static <C extends Compound> SequenceView<C> inverse(Sequence<C> sequence) {\n        SequenceView<C> reverse = new ReversedSequenceView<>(sequence);\n        if (sequence.getCompoundSet().isComplementable()) {\n            return new ComplementSequenceView(reverse);\n        }\n        return reverse;\n    }\n\n    public static <C extends Compound> boolean sequenceEqualityIgnoreCase(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, true);\n    }\n\n    public static <C extends Compound> boolean sequenceEquality(Sequence<C> source, Sequence<C> target) {\n        return baseSequenceEquality(source, target, false);\n    }\n\n    private static <C extends Compound> boolean baseSequenceEquality(Sequence<C> source, Sequence<C> target, boolean ignoreCase) {\n        if (source.getLength() != target.getLength() || \n            !source.getCompoundSet().equals(target.getCompoundSet())) {\n            return false;\n        }\n\n        Iterator<C> sIter = source.iterator();\n        Iterator<C> tIter = target.iterator();\n        while (sIter.hasNext()) {\n            C s = sIter.next();\n            C t = tIter.next();\n            boolean cEqual = ignoreCase ? s.equalsIgnoreCase(t) : s.equals(t);\n            if (!cEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static class SequenceIterator<C extends Compound> implements Iterator<C> {\n\n        private final Sequence<C> sequence;\n        private final int length;\n        private int currentPosition = 0;\n\n        public SequenceIterator(Sequence<C> sequence) {\n            this.sequence = sequence;\n            this.length = sequence.getLength();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return currentPosition < length;\n        }\n\n        @Override\n        public C next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"Exhausted sequence of elements\");\n            }\n            return sequence.getCompoundAt(++currentPosition);\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Cannot remove() on a SequenceIterator\");\n        }\n    }\n}\n",
        0.988,
        0.983,
        0.9770924161659703,
        0.9988608748481167,
        0.9838382687927106,
        214
    ]
}