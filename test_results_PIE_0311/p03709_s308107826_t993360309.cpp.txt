{
    "0": [
        "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define swap(a,b) a^=b^=a^=b\n#define lb(x) ((x)&(-(x)))\n#define inf 0x3f3f3f3f\n#define dalao 1000000007\n#define N 200010\ntypedef long long ll;\nusing namespace std;\nstruct wxh{\n\tint x,v;\n\tbool operator <(const wxh& b)const{return v<b.v;}\n}a[N];\nstruct yjq{\n\tint l,r;\n\tbool operator <(const yjq& b)const{return l<b.l||(l==b.l&&r<b.r);}\n}b[N];\nint n,x[N],t[N],sum[N<<2],tag[N<<2],tag2[N<<2];\ninline void upd(int& a,int b){a+=b;if(a>=dalao)a-=dalao;}\ninline int add(int a,int b){return a+b>=dalao?a+b-dalao:a+b;}\ninline void down(int x,int l,int r){\n\tif(tag2[x]^1){\n\t\tif(l^r){\n\t\t\ttag2[x<<1]=1ll*tag2[x<<1]*tag2[x]%dalao,tag2[x<<1|1]=1ll*tag2[x<<1|1]*tag2[x]%dalao;\n\t\t\ttag[x<<1]=1ll*tag[x<<1]*tag2[x]%dalao,tag[x<<1|1]=1ll*tag[x<<1|1]*tag2[x]%dalao;\n\t\t\tsum[x<<1]=1ll*sum[x<<1]*tag2[x]%dalao,sum[x<<1|1]=1ll*sum[x<<1|1]*tag2[x]%dalao;\n\t\t}\n\t\ttag2[x]=1;\n\t}\n\tif(tag[x]){\n\t\tif(l^r){\n\t\t\tint mid=l+r>>1;\n\t\t\tupd(tag[x<<1],tag[x]),upd(tag[x<<1|1],tag[x]);\n\t\t\tupd(sum[x<<1],1ll*(mid-l+1)*tag[x]%dalao),upd(sum[x<<1|1],1ll*(r-mid)*tag[x]%dalao);\n\t\t}\n\t\ttag[x]=0;\n\t}\n}\ninline void modify(int x,int l,int r,int L,int R,int v){\n\tdown(x,L,R);\n\tif(l==L&&r==R){upd(sum[x],1ll*(r-l+1)*v%dalao),upd(tag[x],v);return;}\n\tint mid=L+R>>1;\n\tif(r<=mid)modify(x<<1,l,r,L,mid,v);\n\telse if(l>mid)modify(x<<1|1,l,r,mid+1,R,v);\n\telse modify(x<<1,l,mid,L,mid,v),modify(x<<1|1,mid+1,r,mid+1,R,v);\n\tsum[x]=add(sum[x<<1],sum[x<<1|1]);\n}\ninline void modify2(int x,int l,int r,int L,int R,int v){\n\tdown(x,L,R);\n\tif(l==L&&r==R){sum[x]=1ll*sum[x]*v%dalao,tag2[x]=1ll*tag2[x]*v%dalao,tag[x]=1ll*tag[x]*v%dalao;return;}\n\tint mid=L+R>>1;\n\tif(r<=mid)modify2(x<<1,l,r,L,mid,v);\n\telse if(l>mid)modify2(x<<1|1,l,r,mid+1,R,v);\n\telse modify2(x<<1,l,mid,L,mid,v),modify2(x<<1|1,mid+1,r,mid+1,R,v);\n\tsum[x]=add(sum[x<<1],sum[x<<1|1]);\n}\ninline int query(int x,int l,int r,int L,int R){\n\tdown(x,L,R);\n\tif(l==L&&r==R)return sum[x];\n\tint mid=L+R>>1;\n\tif(r<=mid)return query(x<<1,l,r,L,mid);\n\telse if(l>mid)return query(x<<1|1,l,r,mid+1,R);\n\treturn add(query(x<<1,l,mid,L,mid),query(x<<1|1,mid+1,r,mid+1,R));\n}\nnamespace init_b{\n\tint mi[N],mx[N],smi[N],smx[N];\n\tinline void main(){\n\t\tmset(mi,inf);\n\t\tfor(int i=1;i<=n;i++)mi[a[i].x]=min(mi[a[i].x],i),mx[a[i].x]=max(mx[a[i].x],i);\n\t\tfor(int i=1;i<=n;i++)smx[i]=max(smx[i-1],mx[i]);\n\t\tsmi[n+1]=inf;\n\t\tfor(int i=n;i;i--)smi[i]=min(smi[i+1],mi[i]);\n\t\tfor(int i=1;i<=n;i++)b[i].l=smi[a[i].x],b[i].r=smx[a[i].x];\n\t}\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i].x,&a[i].v),x[i]=a[i].x;\n\tsort(x+1,x+1+n),sort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)a[i].x=lower_bound(x+1,x+1+n,a[i].x)-x;\n\tinit_b::main();\n\tsort(b+1,b+1+n);\n\tmodify(1,0,0,0,n,1);\n\tfor(int i=1;i<=n;i++){\n\t\tint c=query(1,b[i].l-1,b[i].r,0,n);\n\t\tmodify(1,b[i].r,b[i].r,0,n,c);\n\t\tif(b[i].r<n)modify2(1,b[i].r+1,n,0,n,2);\n\t}\n\tprintf(\"%d\",query(1,n,n,0,n));\n\treturn 0;\n}",
        0.641,
        0.004,
        12407910.988,
        51.689,
        238.579,
        92
    ],
    "1": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n#define N 200010\n#define dalao 1000000007\n\ntypedef long long ll;\nusing namespace std;\n\nstruct wxh {\n    int x, v;\n    bool operator<(const wxh &b) const { return v < b.v; }\n} a[N];\n\nstruct yjq {\n    int l, r;\n    bool operator<(const yjq &b) const { return l < b.l || (l == b.l && r < b.r); }\n} b[N];\n\nint n, x[N];\nvector<int> sum(N << 2, 0), tag(N << 2, 0), tag2(N << 2, 1); \n\ninline void upd(int &a, int b) { a = (a + b) % dalao; }\n\ninline void down(int idx, int l, int r) {\n    if (tag2[idx] != 1) {\n        if (l != r) {\n            tag2[idx << 1] = ((ll)tag2[idx << 1] * tag2[idx]) % dalao;\n            tag2[idx << 1 | 1] = ((ll)tag2[idx << 1 | 1] * tag2[idx]) % dalao;\n            tag[idx << 1] = ((ll)tag[idx << 1] * tag2[idx]) % dalao;\n            tag[idx << 1 | 1] = ((ll)tag[idx << 1 | 1] * tag2[idx]) % dalao;\n            sum[idx << 1] = ((ll)sum[idx << 1] * tag2[idx]) % dalao;\n            sum[idx << 1 | 1] = ((ll)sum[idx << 1 | 1] * tag2[idx]) % dalao;\n        }\n        tag2[idx] = 1;\n    }\n    if (tag[idx]) {\n        if (l != r) {\n            int mid = (l + r) / 2;\n            upd(tag[idx << 1], tag[idx]);\n            upd(tag[idx << 1 | 1], tag[idx]);\n            upd(sum[idx << 1], ((ll)(mid - l + 1) * tag[idx]) % dalao);\n            upd(sum[idx << 1 | 1], ((ll)(r - mid) * tag[idx]) % dalao);\n        }\n        tag[idx] = 0;\n    }\n}\n\ninline void modify(int idx, int l, int r, int L, int R, int v) {\n    down(idx, L, R);\n    if (l == L && r == R) {\n        upd(sum[idx], ((ll)(r - l + 1) * v) % dalao);\n        upd(tag[idx], v);\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (r <= mid) modify(idx << 1, l, r, L, mid, v);\n    else if (l > mid) modify(idx << 1 | 1, l, r, mid + 1, R, v);\n    else {\n        modify(idx << 1, l, mid, L, mid, v);\n        modify(idx << 1 | 1, mid + 1, r, mid + 1, R, v);\n    }\n    sum[idx] = (sum[idx << 1] + sum[idx << 1 | 1]) % dalao;\n}\n\ninline void modify2(int idx, int l, int r, int L, int R, int v) {\n    down(idx, L, R);\n    if (l == L && r == R) {\n        sum[idx] = ((ll)sum[idx] * v) % dalao;\n        tag2[idx] = ((ll)tag2[idx] * v) % dalao;\n        tag[idx] = ((ll)tag[idx] * v) % dalao;\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (r <= mid) modify2(idx << 1, l, r, L, mid, v);\n    else if (l > mid) modify2(idx << 1 | 1, l, r, mid + 1, R, v);\n    else {\n        modify2(idx << 1, l, mid, L, mid, v);\n        modify2(idx << 1 | 1, mid + 1, r, mid + 1, R, v);\n    }\n    sum[idx] = (sum[idx << 1] + sum[idx << 1 | 1]) % dalao;\n}\n\ninline int query(int idx, int l, int r, int L, int R) {\n    down(idx, L, R);\n    if (l == L && r == R) return sum[idx];\n    int mid = (L + R) / 2;\n    if (r <= mid) return query(idx << 1, l, r, L, mid);\n    else if (l > mid) return query(idx << 1 | 1, l, r, mid + 1, R);\n    else return (query(idx << 1, l, mid, L, mid) + query(idx << 1 | 1, mid + 1, r, mid + 1, R)) % dalao;\n}\n\nnamespace init_b {\n    vector<int> mi(N, N), mx(N), smi(N + 1, N), smx(N);\n    \n    void main() {\n        for (int i = 1; i <= n; i++) {\n            mi[a[i].x] = min(mi[a[i].x], i);\n            mx[a[i].x] = max(mx[a[i].x], i);\n        }\n        for (int i = 1; i <= n; i++) smx[i] = max(smx[i - 1], mx[i]);\n        for (int i = n; i >= 1; i--) smi[i] = min(smi[i + 1], mi[i]);\n        for (int i = 1; i <= n; i++) {\n            b[i].l = smi[a[i].x];\n            b[i].r = smx[a[i].x];\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) scanf(\"%d %d\", &a[i].x, &a[i].v), x[i] = a[i].x;\n    sort(x + 1, x + 1 + n);\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; i++) a[i].x = lower_bound(x + 1, x + 1 + n, a[i].x) - x;\n    init_b::main();\n    sort(b + 1, b + 1 + n);\n    modify(1, 0, 0, 0, n, 1);\n\n    for (int i = 1; i <= n; i++) {\n        int c = query(1, b[i].l - 1, b[i].r, 0, n);\n        modify(1, b[i].r, b[i].r, 0, n, c);\n        if (b[i].r < n) modify2(1, b[i].r + 1, n, 0, n, 2);\n    }\n    printf(\"%d\", query(1, n, n, 0, n));\n    \n    return 0;\n}",
        0.14,
        0.153,
        0.151,
        4.43,
        0.153,
        130
    ],
    "2": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define N 200010\n#define MOD 1000000007\n\ntypedef long long ll;\nusing namespace std;\n\nstruct wxh {\n    int x, v;\n    bool operator<(const wxh &b) const { return v < b.v; }\n} a[N];\n\nstruct yjq {\n    int l, r;\n    bool operator<(const yjq &b) const { return l < b.l || (l == b.l && r < b.r); }\n} b[N];\n\nint n, x[N];\nvector<int> sum(N << 2, 0), tag(N << 2, 0), tag2(N << 2, 1);\n\ninline void upd(int &a, int b) {\n    a = (a + b) % MOD;\n}\n\ninline void down(int idx, int l, int r) {\n    if(tag2[idx] != 1) {\n        if(l != r) {\n            int m = (l + r) >> 1;\n            for(int child = 0; child < 2; ++child) {\n                int nxt = (idx << 1) + child;\n                tag2[nxt] = (1LL * tag2[nxt] * tag2[idx]) % MOD;\n                tag[nxt] = (1LL * tag[nxt] * tag2[idx]) % MOD;\n                sum[nxt] = (1LL * sum[nxt] * tag2[idx]) % MOD;\n            }\n        }\n        tag2[idx] = 1;\n    }\n    if(tag[idx] != 0) {\n        if(l != r) {\n            int m = (l + r) >> 1;\n            for(int child = 0; child < 2; ++child) {\n                int nxt = (idx << 1) + child;\n                upd(tag[nxt], tag[idx]);\n                int range = child == 0 ? m - l + 1 : r - m;\n                upd(sum[nxt], (1LL * tag[idx] * range) % MOD);\n            }\n        }\n        tag[idx] = 0;\n    }\n}\n\ninline void modify(int idx, int l, int r, int cl, int cr, int v) {\n    down(idx, cl, cr);\n    if(l == cl && r == cr) {\n        upd(sum[idx], 1LL * (r - l + 1) * v % MOD);\n        upd(tag[idx], v);\n        return;\n    }\n    int m = (cl + cr) >> 1;\n    if(r <= m) modify(idx << 1, l, r, cl, m, v);\n    else if(l > m) modify(idx << 1 | 1, l, r, m + 1, cr, v);\n    else {\n        modify(idx << 1, l, m, cl, m, v);\n        modify(idx << 1 | 1, m + 1, r, m + 1, cr, v);\n    }\n    sum[idx] = (sum[idx << 1] + sum[idx << 1 | 1]) % MOD;\n}\n\ninline void modify2(int idx, int l, int r, int cl, int cr, int v) {\n    down(idx, cl, cr);\n    if(l == cl && r == cr) {\n        sum[idx] = 1LL * sum[idx] * v % MOD;\n        tag2[idx] = 1LL * tag2[idx] * v % MOD;\n        tag[idx] = 1LL * tag[idx] * v % MOD;\n        return;\n    }\n    int m = (cl + cr) >> 1;\n    if(r <= m) modify2(idx << 1, l, r, cl, m, v);\n    else if(l > m) modify2(idx << 1 | 1, l, r, m + 1, cr, v);\n    else {\n        modify2(idx << 1, l, m, cl, m, v);\n        modify2(idx << 1 | 1, m + 1, r, m + 1, cr, v);\n    }\n    sum[idx] = (sum[idx << 1] + sum[idx << 1 | 1]) % MOD;\n}\n\ninline int query(int idx, int l, int r, int cl, int cr) {\n    down(idx, cl, cr);\n    if(l == cl && r == cr) return sum[idx];\n    int m = (cl + cr) >> 1;\n    if(r <= m) return query(idx << 1, l, r, cl, m);\n    else if(l > m) return query(idx << 1 | 1, l, r, m + 1, cr);\n    else {\n        int leftPart = query(idx << 1, l, m, cl, m);\n        int rightPart = query(idx << 1 | 1, m + 1, r, m + 1, cr);\n        return (leftPart + rightPart) % MOD;\n    }\n}\n\nnamespace init_b {\n    vector<int> mi(N, N), mx(N), smi(N + 1, N), smx(N);\n    \n    void main() {\n        for(int i = 1; i <= n; i++) {\n            mi[a[i].x] = min(mi[a[i].x], i);\n            mx[a[i].x] = max(mx[a[i].x], i);\n        }\n        for(int i = 1; i <= n; i++) smx[i] = max(smx[i - 1], mx[i]);\n        for(int i = n; i >= 1; i--) smi[i] = min(smi[i + 1], mi[i]);\n        for(int i = 1; i <= n; i++) {\n            b[i].l = smi[a[i].x];\n            b[i].r = smx[a[i].x];\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++) scanf(\"%d %d\", &a[i].x, &a[i].v), x[i] = a[i].x;\n    sort(x + 1, x + 1 + n);\n    sort(a + 1, a + 1 + n);\n    for(int i = 1; i <= n; i++) a[i].x = lower_bound(x + 1, x + 1 + n, a[i].x) - x;\n    init_b::main();\n    sort(b + 1, b + 1 + n);\n\n    modify(1, 0, 0, 0, n, 1);\n\n    for(int i = 1; i <= n; i++) {\n        int c = query(1, b[i].l - 1, b[i].r, 0, n);\n        modify(1, b[i].r, b[i].r, 0, n, c);\n        if(b[i].r < n) modify2(1, b[i].r + 1, n, 0, n, 2);\n    }\n\n    printf(\"%d\\n\", query(1, n, n, 0, n));\n    return 0;\n}",
        0.138,
        0.149,
        0.147,
        3.527,
        0.149,
        139
    ]
}